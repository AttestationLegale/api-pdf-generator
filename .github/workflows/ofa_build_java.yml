############################################################
# Agnostic workflow (usually triggered by others)
# Runs Java 8 applications build and deploy for any branch/env
#
# IMPORTANT: could be moved to a "composite" action, but
# ACT (testing tool) does not support it yet
# and we want to keep the possibility of local testing
# Should be supported starting from act v0.2.22+
############################################################

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
name: "GENERIC deploy service"

on:
    workflow_dispatch:
        # Inputs the workflow accepts.
        inputs:
            repository_branch:
                description: "Branch to build:"
                required: true
                default: "dev"
            ofa_environment:
                description: "Defines the env configuration (integration, staging):"
                required: true
                default: "integration"
            perform_deployment:
                description: "Enable or disable deployment to AWS:"
                required: true
                default: "false"
            image_prefix:
                description: "Tag an image with a pref (ex: 'RC-' = 'RC-X.Y.Z'):"
                required: false
                default: ""


env:
    # Secrets required
    # AWS_ECS_<DEV|STG|PROD>_DEPLOYER_ACCESS_KEY_ID
    AWS_ECS_SERVICE_DEPLOYER_ACCESS_KEY_ID_SECRET_NAME:  # Filled by workflow
    # AWS_ECS_<DEV|STG|PROD>_DEPLOYER_SECRET_ACCESS_KEY
    AWS_ECS_SERVICE_DEPLOYER_SECRET_ACCESS_KEY_SECRET_NAME:  # Filled by workflow
    # ACTIONS_ACCESS_TOKEN
    # AWS_PROD_SECRET_ACCESS_KEY
    # AWS_PROD_ACCESS_KEY_ID
    # MAVEN_OFA_USERNAME
    # MAVEN_OFA_PASSWORD

    # Application configuration
    REPO_BRANCH: ${{ github.event.inputs.repository_branch }}
    OFA_ENV: ${{ github.event.inputs.ofa_environment }}
    PERFORM_DEPLOY: ${{ github.event.inputs.perform_deployment }}
    IMAGE_PREFIX: ${{ github.event.inputs.image_prefix }}

    # Workflow runtime configuration
    ENV_NAME: # Filled by workflow
    IMAGE_NAME: # Filled by workflow
    REGISTRY_NAME: # Filled by workflow
    SERVICE:  # Filled by workflow
    CLUSTER:  # Filled by workflow
    AWS_REGION:  # Filled by workflow
    AWS_ECS_SERVICE_DEPLOYER_ACCESS_KEY_ID:  # Filled by workflow
    AWS_ECS_SERVICE_DEPLOYER_SECRET_ACCESS_KEY:  # Filled by workflow
    GIST_ID:  # Filled by workflow

jobs:
    # This pre-job allows to save minutes (and by so, money) in case of duplicated runs
    pre_job:
        continue-on-error: true
        runs-on: ubuntu-latest
        name: "Cancel previous branch jobs"
        timeout-minutes: 5
        steps:
            -   name: "Cancel duplicate runs"
                id: skip_check
                uses: fkirc/skip-duplicate-actions@master
                with:
                    cancel_others: true
                    concurrent_skipping: "always"
                    github_token: ${{ secrets.ACTIONS_ACCESS_TOKEN  }}

    ofa_build_image_job:
        runs-on: ubuntu-latest
        name: "Build Docker image"
        timeout-minutes: 30
        steps:
              # To use this repository's private action, you must check out the repository
            -   name: "Checkout"
                id: checkout
                uses: actions/checkout@v2
                with:
                    ref: ${{ env.REPO_BRANCH }}
                    token: ${{ secrets.ACTIONS_ACCESS_TOKEN  }}

            # Provides useful common env vars (like repository name)
            -   name: "Init common env vars"
                uses: FranzDiebold/github-env-vars-action@v2

            -   name: "Load ofa_environment"
                uses: Steph0/dotenv-configserver@v1
                with:
                    repository: "AttestationLegale/ofa_delivery_configserver"
                    token: ${{ secrets.ACTIONS_ACCESS_TOKEN  }}
                    directory: "${{ env.CI_REPOSITORY_NAME }}"
                    profile: "${{ env.OFA_ENV }}"

            -   name: "Init application runtime env vars"
                id: init_env
                run: |
                    echo "This step might take some time depending on what is in cache... please be patient"

                    # Get only repository name
                    echo "IMAGE_NAME=$(echo ${GITHUB_REPOSITORY} | awk -F / '{print $2}')" >> $GITHUB_ENV
                    echo "Exported IMAGE_NAME from [${GITHUB_REPOSITORY}]"

                    # Extract project version (ignoring <parent> bloc)
                    # Unix method preferred over mvn command, because mvn would download dependencies ($$: ~2 minutes)
                    export VERSION=$(
                      awk '
                        /<dependenc/{exit}
                        /<parent>/{parent++};
                        /<version>/{
                          if (parent == 1) {
                            sub(/.*<version>/, "");
                            sub(/<.*/, "");
                            parent_version = $0;
                          } else {
                            sub(/.*<version>/, "");
                            sub(/<.*/, "");
                            version = $0;
                            exit
                          }
                        }
                        /<\/parent>/{parent--};
                        END {
                          print (version == "") ? parent_version : version
                        }' pom.xml
                      )
                    echo "APP_VERSION=$(echo ${VERSION})" >> $GITHUB_ENV
                    echo "Exported APP_VERSION:[${VERSION}]"

                    # Get env related secrets
                    echo "AWS_ECS_SERVICE_DEPLOYER_ACCESS_KEY_ID=$(echo ${{ secrets[format('{0}', env.AWS_ECS_SERVICE_DEPLOYER_ACCESS_KEY_ID_SECRET_NAME)] }})" >> $GITHUB_ENV
                    echo "Exported AWS_ECS_SERVICE_DEPLOYER_ACCESS_KEY_ID secret"

                    echo "AWS_ECS_SERVICE_DEPLOYER_SECRET_ACCESS_KEY=$(echo ${{ secrets[format('{0}', env.AWS_ECS_SERVICE_DEPLOYER_SECRET_ACCESS_KEY_SECRET_NAME)] }})" >> $GITHUB_ENV
                    echo "Exported AWS_ECS_SERVICE_DEPLOYER_SECRET_ACCESS_KEY secret"
                shell: bash

            # Needed to access ofa-base during build
            -   name: "Configure AWS credentials"
                id: aws_creds_prod_key
                uses: aws-actions/configure-aws-credentials@v1
                with:
                    aws-access-key-id: ${{ secrets.AWS_PROD_ACCESS_KEY_ID }}
                    aws-secret-access-key: ${{ secrets.AWS_PROD_SECRET_ACCESS_KEY }}
                    aws-region: ${{ env.AWS_REGION }}

            -   name: Login to Amazon ECR
                id: login_ecr_prod_key
                uses: aws-actions/amazon-ecr-login@v1

            # Needed to access ECR during build
            -   name: "Configure AWS credentials"
                id: aws_creds_dev_deployer
                uses: aws-actions/configure-aws-credentials@v1
                with:
                    aws-access-key-id: ${{ env.AWS_ECS_SERVICE_DEPLOYER_ACCESS_KEY_ID }}
                    aws-secret-access-key: ${{ env.AWS_ECS_SERVICE_DEPLOYER_SECRET_ACCESS_KEY }}
                    aws-region: ${{ env.AWS_REGION }}

            -   name: "Login to Amazon ECR"
                id: login_ecr_dev_deployer
                uses: aws-actions/amazon-ecr-login@v1


            # Cache initialization
            -   name: "Set up Docker Buildx"
                id: init_buildx
                uses: docker/setup-buildx-action@v1
                with:
                    driver-opts: image=moby/buildkit:master

            -   name: "Cache Docker layers"
                id: cache_docker
                uses: actions/cache@v2
                with:
                    path: /tmp/.buildx-cache
                    key: ${{ runner.os }}-buildx-${{ github.sha }}
                    restore-keys: |
                        ${{ runner.os }}-buildx-

            -   name: "Push to ECR"
                id: docker_push
                uses: docker/build-push-action@v2
                with:
                    push: true
                    context: .
                    file: Dockerfile
                    build-args: |
                        APP_HOME=./
                    secrets: |
                        MAVEN_OFA_USERNAME=${{ secrets.MAVEN_OFA_USERNAME }}
                        MAVEN_OFA_PASSWORD=${{ secrets.MAVEN_OFA_PASSWORD }}
                    platforms: linux/amd64
                    # Requires full tag to push to AWS
                    tags: |
                        ${{ steps.login_ecr_dev_deployer.outputs.registry }}/${{ env.REGISTRY_NAME }}:${{ env.APP_VERSION }}
                        ${{ steps.login_ecr_dev_deployer.outputs.registry }}/${{ env.REGISTRY_NAME }}:${{ env.IMAGE_PREFIX }}${{ env.APP_VERSION }}
                        ${{ steps.login_ecr_dev_deployer.outputs.registry }}/${{ env.REGISTRY_NAME }}:latest
                        ${{ steps.login_ecr_dev_deployer.outputs.registry }}/${{ env.REGISTRY_NAME }}:github-${{ env.CI_SHA_SHORT }}
                    cache-from: type=local,src=/tmp/.buildx-cache
                    cache-to: type=local,dest=/tmp/.buildx-cache-new

            #   # This ugly bit is necessary if you don't want your cache to grow forever
            #   # till it hits GitHub's limit of 5GB.
            #   # Temp fix
            #   # https://github.com/docker/build-push-action/issues/252
            #   # https://github.com/moby/buildkit/issues/1896
            -   name: "Move cache"
                run: |
                    rm -rf /tmp/.buildx-cache
                    mv /tmp/.buildx-cache-new /tmp/.buildx-cache

            -   name: "Deploy to ECS"
                if: ${{ env.PERFORM_DEPLOY == 'true' }}
                id: aws_task_deployment
                run: |
                    curl https://raw.githubusercontent.com/AttestationLegale/ecs-deploy/master/ecs-deploy > ./ecs-deploy
                    chmod +x ecs-deploy
                    ./ecs-deploy \
                        -n ${{ env.SERVICE }} \
                        -c ${{ env.CLUSTER }} \
                        -i ${{ steps.login_ecr_dev_deployer.outputs.registry }}/${{ env.REGISTRY_NAME }}:latest \
                        -r ${{ env.AWS_REGION }} \
                        -k ${{ env.AWS_ECS_SERVICE_DEPLOYER_ACCESS_KEY_ID }} \
                        -s ${{ env.AWS_ECS_SERVICE_DEPLOYER_SECRET_ACCESS_KEY }} \
                        --force-new-deployment \
                        --skip-deployments-check
                shell: bash

            -   name: "Set current date as env variable"
                id: current_date
                if: ${{ success() && env.GIST_ID && env.PERFORM_DEPLOY == 'true' }}
                run: echo "NOW=$(date +'%Y-%m-%dT%H:%M:%S')" >> $GITHUB_ENV

            -   name: "Create deployment badge"
                uses: schneegans/dynamic-badges-action@v1.0.0
                if: ${{ success() && env.GIST_ID && env.PERFORM_DEPLOY == 'true' }}
                # Not failing workflow for a badge
                continue-on-error: true
                with:
                    auth: ${{ secrets.GIST_BADGE }}
                    gistID: ${{ env.GIST_ID }}
                    filename: ${{ env.GIST_FILENAME }}
                    namedLogo: "amazon"
                    label: "${{ env.ENV_NAME }} - ref:[${{ env.REPO_BRANCH }}] - ${{ env.NOW }}"
                    message: ${{ env.APP_VERSION }}
                    color: green

            -   name: Logout of Amazon ECR
                if: always()
                run: docker logout ${{ steps.login_ecr_dev_deployer.outputs.registry }}
